// numericalIntegration.cpp  
// Author: Luke P
/* Program to compute midpoint formula (aka Middle Riemann Sum formula), parabolic formula (aka Simpson's Rule), and trapezoidal formula numerical integration techniques.

   Just as a refresher, integration is the technique of measuring the area between one of the axes to the curve or line generated by an eqaution.
   The two main types of integration are analytic integration and numeric integration.
   Analytic integration is the process of directly translating the original equation into 
   a new equation which will allow for the computing of the area from the curve to the axis.
   Numerical integration is a technique of approximating the area under the curve generated by an equation. 
   It is used when the equation is not easily integrated through analytic integration. 
   It is very time-consuming to do numerical integration and error-prone since it requires working with long decimals in many cases.
   My program uses the formulas found in the Calculus 2 textbook which I used in the 2021 spring semester.
   I adapted the formulas into c++ code and designed classes to contain the variables that need to exist to do the numeric integration.
   
   A good article on numerical integration is https://opentextbc.ca/calculusv2openstax/chapter/numerical-integration/ 
   I added/utilized the following: exception handling, operator overloading, 4 classes, inheritance, vectors, function polymorphism, and other programming constructs.
*/

 // Modify Line 87 (or wherever the function (double NumericalIntegration:: equation(double& x)) is) with your particular equation as desired. The line is currently(double equation = 3 * pow(e, -2 * x);) unless someone modified it but it should have the same form.

#pragma once
#include <iostream>
#include <cmath> // Needed for the pow function which does exponentiation.
#include <stdexcept> // Needed for the overflow and underflow exception handling.
#include <vector> // Needed for the vector data structure.
#include <iomanip> // Needed for the formatting of the output.
#include <string> // Needed for the toString method.


using namespace std;

// Class that has members common to all the derived classes of the Numerical Integration class / technique.
class NumericalIntegration {

protected:
	double a; // This is the starting x point on the graph. It's the left limit of integration
	double b; // This is the end point of x on the graph. It's the right limit of integration
	double numberOfSubintervals; // This is the number of subintervals that is used for the approximating of the area under the curve.
	int precision; // This sets the amount of decimal values for the displayed end value(s).
	double deltaX; // This is the size of each partition 
    double pi, e; // Will be initialized to pi = 3.14159265358979, e = 2.71828182845904;
	
	vector<double> x_k; // Represents the rightmost x value for each subinterval. It will store the x points as well for printing them out if desired.
	

public:

	 // NumericalIntegration() { a = 1; b = 1; numberOfSubintervals = 2; precision = 2; deltaX = ((a - b) / numberOfSubintervals); }
	~NumericalIntegration() {}

	NumericalIntegration() {
		
		a = initializeLowerBound();
		b = initializeUpperBound();
		numberOfSubintervals = initializeSubintervals();
		
		if (b > a) { 
			deltaX = (b - a) / numberOfSubintervals; // This is the standard formula for calculating how much x changes in each iteration of the summation process.
		}
		else { // If the user put a higher number for b then this will make sure the proper formula is chosen
			deltaX = (a - b) / numberOfSubintervals; // This treats a as the upper bound if the user input a greater value for the lowerBound compared to the upperBound.
		}
		precision = initializePrecision();

		cout << "Delta x = " << deltaX << endl;
		pi = 3.14159265358979; // This is pi approximated to 14 decimal places.
		e = 2.71828182845904;  // This is e approximated to 14 decimal places.
	}

	double equation(double& x);    // Used to hold the equation the user is trying to do the integration on.
	double initializeLowerBound(); // Used to initialize the lower bound which is the left point you choose to measure the area from.
	double initializeUpperBound(); // Used to initialize the upper bound which is the right point you choose to measure the area from.
	int initializeSubintervals();  // This is used to initialize the number of subintervals the formula will use to approximate the area under the curve.
	int initializePrecision();     // Initializes precision of decimal places for the output.
	
};


/* Used to hold the equation the user is trying to do the integration on. 
THIS FUNCTION IS VERY IMPORTANT: Modify the equation inside this function to
change which equation you do the numerical integration on.*/
double NumericalIntegration:: equation(double& x) {
	
	double heightOfShape = 0; // This will hold the height of the new shape which will be used when computing the area of the particular subinterval.
	
	double equation = 3 * pow(e, -2 * x); // VERY IMPORTANT: Modify the expression to fit the equation you're doing wanting to do the numerical integration on.
	
	heightOfShape = equation; // This assignment is necessary for making the more intuitive name (heightOfShape) be the variable that is returned by this function since that's what the equation actually returns. 

	return heightOfShape;
}

// Used to initialize the lower bound which is the left point you choose to measure the area from.
double NumericalIntegration::initializeLowerBound() {

	bool isValidNumber = false;
	double lowerBound = 0;

	do {
		try {
			cout << "Enter the lower bound of integration: ";
			cin >> lowerBound;

			if (lowerBound > numeric_limits<double>::max()) // Catches too large of inputs.
				throw overflow_error("Too large of a number entered");
			if (!cin.good()) {
				throw invalid_argument("Invalid argument entered; Only input numbers for the lower bound.");
			}

			isValidNumber = true;

			return lowerBound; // Function only reaches this point if the input was valid.

		}
		catch (invalid_argument errMsg) {
			cout << errMsg.what() << endl;
			cin.clear();
			cin.ignore(INT_MAX, '\n');
		}
		catch (overflow_error errMsg) {

			cout << errMsg.what() << endl;
			cin.clear();                   // Used to clear the error flags.
			cin.ignore(INT_MAX, '\n');    // Used to ignore the input buffer until the newline character is encountered.
		}
	} while (! isValidNumber);

	return lowerBound; // Function shouldn't reach this point but just in case I put this return statement here.
}

// Used to initialize the upper bound which is the right point you choose to measure the area from.
double NumericalIntegration::initializeUpperBound() {

	bool isValidNumber = false;
	double upperBound = 0;

	do {
		try {
			
			cout << "Enter the upper bound of integration: ";
			cin >> upperBound;

			if (upperBound > numeric_limits<double>::max()) // Catches too large of inputs.
				throw overflow_error("Too large of a number entered");
			if (!cin.good()) {
				throw invalid_argument("Invalid argument entered; Only input numbers for the upper bound.");
			}
			
			isValidNumber = true;

			return upperBound; // Function only reaches this point if the input was valid.

		}
		catch (invalid_argument errMsg) {
			cout << errMsg.what() << endl;
			cin.clear();
			cin.ignore(INT_MAX, '\n');
		}
		catch (overflow_error errMsg) {

			cout << errMsg.what() << endl;
			cin.clear();                   // Used to clear the error flags.
			cin.ignore(INT_MAX, '\n');    // Used to ignore the input buffer until the newline character is encountered.
		}
	} while (!isValidNumber);

	return upperBound; // Function shouldn't reach this point but just in case I put this return statement here.
}

// This is used to initialize the number of subintervals the formula will use to approximate the area under the curve.
int NumericalIntegration::initializeSubintervals() {

	bool isValidNumber = false;
	int numOfSubIntervals = 0;

	do {
		try {

			cout << "Enter the number of subintervals: ";
			cin >> numOfSubIntervals;

			if (numOfSubIntervals > numeric_limits<double>::max()) // Catches too large of inputs.
				throw overflow_error("Too large of a number entered");
			
			if (!cin.good()) {
				throw invalid_argument("Invalid argument entered; Only input numbers for the subinterval size.");
			}

			isValidNumber = true;

			return numOfSubIntervals; // Function only reaches this point if the input was valid.

		}
		catch (invalid_argument errMsg) {
			cout << errMsg.what() << endl;
			cin.clear();
			cin.ignore(INT_MAX, '\n');
		}
		catch (overflow_error errMsg) {

			cout << errMsg.what() << endl;
			cin.clear();                   // Used to clear the error flags.
			cin.ignore(INT_MAX, '\n');    // Used to ignore the input buffer until the newline character is encountered.
		}
	} while (!isValidNumber);
	
	return numOfSubIntervals;
}

// Initializes precision of decimal places for the output.
int NumericalIntegration::initializePrecision() {

	bool isValidNumber = false;
	int precise = 0;

	do {
		try {

			cout << "Enter the precision: ";
			cin >> precise;

			if (precise > numeric_limits<int>::max()) // Catches too large of inputs.
				throw overflow_error("Too large of a number entered");

			if (!cin.good()) {
				throw invalid_argument("Invalid argument entered; Only input numbers for the precision.");
			}

			isValidNumber = true;

			return precise; // Function only reaches this point if the input was valid.

		}
		catch (invalid_argument errMsg) {
			cout << errMsg.what() << endl;
			cin.clear();
			cin.ignore(INT_MAX, '\n');
		}
		catch (overflow_error errMsg) {

			cout << errMsg.what() << endl;
			cin.clear();                   // Used to clear the error flags.
			cin.ignore(INT_MAX, '\n');    // Used to ignore the input buffer until the newline character is encountered.
		}
	} while (!isValidNumber);

	return precise;

}

/* Derived class of NumericalIntegratio class.
This uses the set of rectangles' areas which lengths are equal 
to the value of deltaX (The change in x for each subinterval) 
and whose heights are equal to the value found 
when the specific x is plugged into the equation to 
approximate the area under the curve.
*/
class MidpointFormula : protected NumericalIntegration {

private:
	vector<double> midPoint; // Holds the midpoint x for when the midpoint formula integration technique is used.
	vector<double> midPointHeight; // This holds the height from the curve to the x-axis at the specific x value found during the iteration process.
	double midpointResultOfIntegration;
public:

	// Default constructor.
	MidpointFormula() : NumericalIntegration(){
	
		midpointResultOfIntegration = iteratingProcess();
	} 
	// Default destructor.
	~MidpointFormula(){ 
	} 
	
	double iteratingProcess(); // This computes and adds the areas of the rectangles that are fit underneath the curve.
	double getResultOfIntegration(); // Get method for the result of the iteratingProcess.
	string toString();
	void printTable();
	int getPrecision() {
		return precision;
	}
};

double MidpointFormula::iteratingProcess() {
	
	double x = 0;
	double areaFromMidFormula = 0;
	midPoint.push_back(0);
	
	
	for (int i = 0; i <= numberOfSubintervals; i++)
	{
		
		// This stores all the x values 
		x_k.push_back( a + (i * deltaX) );
		
		// This if loads the points(terms) of the midpoint formula into 
		// the vector up to and including the last point.
		if ((i > 0) && (i <= numberOfSubintervals))
		{
			midPoint.push_back( (x_k[(i - 1)] + x_k[i]) / 2 );
			
			x = midPoint[i];
			
			midPointHeight.push_back(equation(x));
			
			areaFromMidFormula = areaFromMidFormula + (midPointHeight[midPointHeight.size() - 1]);
			if (i == numberOfSubintervals) {
				areaFromMidFormula = areaFromMidFormula * deltaX;
			}
		}
	
	}

	return areaFromMidFormula;
}

double MidpointFormula::getResultOfIntegration() {
	return midpointResultOfIntegration;
}
string MidpointFormula::toString() {

	string result = "Result of Midpoint integration: " + to_string(getResultOfIntegration());
	return result;
}
void MidpointFormula::printTable() {
	cout << "1st column: step number, 2nd column: x's value for that step, 3rd column: midpoint value at that step,\
			\n 4th column: Height of curve directly perpundicular to the midpoint.\n";
		cout << "k       Xk           Mk            f(Mk)" << endl;

		for (int i = 0; i < numberOfSubintervals; i++) {
			char fill = ' ';
			cout << showpoint << fixed << setprecision(precision);
			cout << i << right << setw(12) << setfill(fill) << x_k[i]
				<< right << setw(14) << setfill(fill) << midPoint[i] <<
				right << setw(14) << setfill(fill) << midPointHeight[i] << endl;
		}
}
// Class to hold the methods and members that allow for numerical integration by way of the trapezoidal formula to occur.
class TrapezoidalFormula : protected NumericalIntegration {

private:

	vector<double> f_xk; // This stores the distance(height) from the x-axis to the point of the curve generated by the equation in the equation function.
	double trapezoidalResultOfIntegration;
public:

	// Default Constructor.
	TrapezoidalFormula() : NumericalIntegration (){

		trapezoidalResultOfIntegration = iteratingProcess();
	};
	~TrapezoidalFormula() {}; // Default Destructor.

	double iteratingProcess(); // Inherited method that is modified to fit the Trapezoidal formula class.
	double getResultOfIntegration(); // Gets the area computed from the iterative process.
	string toString();
	void printTable();
	int getPrecision() {
		return precision;
	}
};

// This function computes and sums the areas of the set of trapezoids that are fit underneath the curve.
// By summing all the areas, the approximation of the area from the curve to the x-axis is achieved.
double TrapezoidalFormula::iteratingProcess() {

	double trapTerm1; // Stores the first term of the iteration process for the trapezoidal integration process.
	double trapLastTerm; // This stores the last term of the process. 
	double trap = 0; // This is used to store the sum of all the middle terms of the process.

	for (int i = 0; i <= numberOfSubintervals; i++)
	{

		// This stores all the x values 
		x_k.push_back( a + (i * deltaX) );

		f_xk.push_back( equation(x_k[i]) ); // This stores all the y values (the heights).

		// This stores the 1st term for the Trapezoidal formula.
		if (i == 0)
		{
			trapTerm1 = ((f_xk[i]) / 2); // This can be seen as the distance of the curve from the x-axis to the curve generated by the equation divided by 2.
		}
		else {
			// This sums the middle terms of the trapezoidal formula.
			if ((i >= 1) && (i < numberOfSubintervals))
			{
				trap = trap + (f_xk[i]); // Sums trap by the value found when x was passed into the equation.
			}
			else {
				
				// This stores the last term for the Trapezoidal and
		        // contains the final summation of the terms for the formula.
				if (i == numberOfSubintervals)
				{
					trapLastTerm = ((f_xk[i]) / 2); // Computes value for the last term.

					trap = trap + trapTerm1+ trapLastTerm; // This adds all the heights together.
					trap = trap * deltaX; // This multiplies the sums by the change in x for each step.
				}
			}
		}
	}

	return trap; // Returns the approximation for the area under the curve generated by the equation and bounded by the lower and upper bounds.
}

// Getter method for the result of the trapezoidal numerical integration.
double TrapezoidalFormula::getResultOfIntegration() {

	return trapezoidalResultOfIntegration;
}

string TrapezoidalFormula::toString() {

	string result = "Result of trapezoidal integration: " + to_string(getResultOfIntegration()) + " ";
	return result;
}

void TrapezoidalFormula::printTable() {

	cout << "1st column: step number, \n2nd column: x's value for that step, \n3rd column: Height of curve at that particular x value,\n";
	cout << "k       Xk            f(Xk)" << endl;

	for (int i = 0; i < numberOfSubintervals; i++) {
		char fill = ' ';
		cout << showpoint << fixed << setprecision(precision);
		cout << i << right << setw(12) << setfill(fill) << x_k[i]
			<< right << setw(13) << setfill(fill) << f_xk[i] << endl;
	}
}

// This is the class that holds the methods and variables to do the parabolic integration.
class ParabolicFormula : protected NumericalIntegration {

private:

	vector<double> f_xk; // This stores the distance(height) from the x-axis to the point of the curve generated by the equation in the equation function.
	double parabolicResultOfIntegration; // This stores the area computed by the iterative parabolic formula process.
	
public:

	// Default Constructor for ParabolicFormula class.
	ParabolicFormula() : NumericalIntegration(){
	
		parabolicResultOfIntegration = iteratingProcess();
	} 
	~ParabolicFormula(){} // Default destructor.

	double iteratingProcess();
	double getResultOfIntegration();
	string toString();
	void printTable();
	int getPrecision() {
		return precision;
	}
};

//This is the function that does the parabolic(aka Simpson's rule) numerical integration .
double ParabolicFormula::iteratingProcess() {
	/*These variables are used to store the sum of the various terms associated with the parabolic formula.
	There are so many because in that way they may capture the different terms from fitting parabolas to the curve.*/
	double parabolicArea = 0,
		parabolic1 = 0,
		parabolicN = 0,
		parabolic2 = 0,
		parabolic4 = 0;

	printf("Arrived in parabolic iter:");
	cout << endl;
	for (int i = 0; i <= numberOfSubintervals; i++) // This runs the number of times that the user specified when they entered the value for the subintervals.
	{
		// This vector stores all the x values 
		x_k.push_back( a + (i * deltaX) );

		// This stores all the height(y) values.
		f_xk.push_back( equation(x_k[i]) ); 
		
		// This stores the 1st terms for the Parabolic formula.
		if (i == 0) // This runs on the 1st step of the iterative process.
		{
			parabolic1 = (f_xk[i]);
		}

		// This collects the sum of the parabolic terms that have 2 as a coefficient.
		if ((i % 2 == 1) && (i != numberOfSubintervals)) // This if runs on the odd steps of the iterative process.
		{
			parabolic4 = parabolic4 + (4 * f_xk[i]);
		}

		// This collects the sum of the parabolic terms that have 4 as a coefficient. 
		if ((i % 2 == 0) && (i != 0) && (i != numberOfSubintervals)) // This if runs on the even steps of the iterative process.
		{
			parabolic2 = parabolic2 + (2 * f_xk[i]);
		}

		// This stores the last term for the Parabolic formula.
		// It also contains the final summation of the
		// terms for the parabolic formula.
		if (i == numberOfSubintervals)
		{
			parabolicN = parabolic1 + (f_xk[i]);

			parabolicArea = parabolicN + parabolic2 + parabolic4;

			parabolicArea = parabolicArea * deltaX;

			parabolicArea = parabolicArea / 3;
		}

	}

	return parabolicArea;
}
// Getter method for the result of the parabolic numeric integration.
double ParabolicFormula::getResultOfIntegration() {

	return parabolicResultOfIntegration;
}

string ParabolicFormula::toString() {

	// Needed to get the result of integration to be the specified precision.
	double number = getResultOfIntegration();
	number = number * pow(10, precision); // Shifts the value over precision number of places.
	number = static_cast<int> (number); // This leads to the decimal values being trimmed due to the static_cst to an int data type.
	number = static_cast<double> (number); // This turns number back to a double variable so it can be have the decimal values shifted back.
	number = number / pow(10, precision); // This reverses the first pow operation and now there will be a precision number of decimals.

	// This is needed to get the result of integration to be a string type so it can be returned as a string.
	string resultPrecision = to_string(number);
	
	string result = "Result of parabolic integration: " + resultPrecision;
	return result;
}

void ParabolicFormula::printTable() {

	cout << "1st column: step number, \n2nd column: x's value for that step, \n3rd column: Height of curve at that particular x value,\n";
	cout << "k       Xk            f(Xk)       " << endl;

	for (int i = 0; i < numberOfSubintervals; i++) {
		char fill = ' ';
		cout << showpoint << fixed << setprecision(precision);
		cout << i << right << setw(12) << setfill(fill) << x_k[i]
			<< right << setw(13) << setfill(fill) << f_xk[i] << endl;
	}
}


// Operator overloading of << for the MidpointFormula class objects.
ostream& operator<<(ostream& integrationInfo, MidpointFormula& integrationResult)
{
	integrationInfo << integrationResult.toString();
	return integrationInfo;
}

// Operator overloading of << for the TrapezoidalFormula class objects.
ostream& operator<<(ostream& integrationInfo, TrapezoidalFormula& integrationResult)
{
	integrationInfo << integrationResult.toString();
	return integrationInfo;
}

// Operator overloading of << for the parabolicFormula class objects.
ostream& operator<<(ostream& integrationInfo, ParabolicFormula &integrationResult)
{
	integrationInfo << integrationResult.toString();
	return integrationInfo;
}
//***************************************************************************************************************************************************************************************
// End of class method definitions and operator overloading.

int inputValditionForChoice(int min, int max);

// Main program to do work with the objects of the derived classes of the NumericalIntegration base class.
int main(int* arg, int** kargs) {

	// This info is in comment form at the top of the program and this can be turned into a comment if you're familiar with numerical integration so that the console output is more neat.
	cout << "Just as a refresher, integration is the technique of measuring the area between \n"\
		"one of the axes to the curve or line generated by an eqaution.\n"\
		"The two main types of integration are analytic integration and numeric integration.\n"\
		"Analytic integration is the process of directly translating the original equation into\n"\
		"a new equation which will allow for the computing of the area from the curve to the axis.\n"\
		"Numerical integration is a technique of approximating the area under the curve generated by an equation.\n"\
		"It is used when the equation is not easily integrated through analytic integration.\n"\
		"It is time-consuming to do numerical integration by hand,also it requires working with long decimals so it error-prone.\n"\
		"My program uses the mathematical algorithms found in the Calculus 2 textbook which I used in the 2021 spring semester.\n"\
		"I adapted those mathematical algorithms into c++ code which solves the numerical integration for you.\n"\
		"The one thing you have to do to make this program extremely versatile is modify \n"\
		"the equation on line 86 of the source code to fit the equation you're trying to numerically integrate.\n\n"\
		"An important note, the number of subintervals specifies the number of the shapes you fit under the curve;\n"\
		"the more subintervals, the more accurate the approximation is." << endl;

	bool isSessionDone = false; // Used to control the loop that runs until the user decides to exit the session. Ends the session when set to true.
	int integrationChoice; // Used to control which integration numerical technqiue is used.
	int printTableChoice; // Used to control whether the table of intermediate x and y values are printed.

	while (!isSessionDone) {
		cout << "\n"; // Spaces out the output.
		cout << "The equation I'm using to demonstrate the program in line 86 is currently:\nf(x) = 3 * e ^ (-2 * x)\n"\
			"Now choose which method of numeric integration you would like to use: \n"\
			"1) Midpoint Formula\n"\
			"2) Trapezoidal Formula\n"\
			"3) Parabolic Formula \n"\
			"0) To exit\n"
			"Choice: ";

		integrationChoice = inputValditionForChoice(0, 4); // Returns an integer between 0 up to and including 3.
		
		if (integrationChoice == 0) {

			cout << "Program closing." << endl;
			isSessionDone = true; // Ends the session when set to true.
			return 0;
		}
		else {
			if (integrationChoice == 1) {

				MidpointFormula(*midFormObj) = new MidpointFormula; // Creates pointer to MidpointFormula object. Must be destroyed at the end of the switch structure to make sure memory is managed properly.
				cout << (*midFormObj) << endl; // Prints the result of the midpoint integration.

				cout << "Would you like to see the table of values of the intermediate x and y values?\n"\
					<< "Enter 0 for no or 1 for yes: ";
				printTableChoice = inputValditionForChoice(0, 2);
				cout << "\n";
				if (printTableChoice == 1){
					(*midFormObj).printTable(); // Prints the table of values.
				}

				delete midFormObj; // Deletes the object so that the memory space can be reallocated for the next objects and so that the reinitialization of the members of the base class: NumericIntegration, will be new each time a new object is created in the next iteration of the loop.

				continue; // Skips back to the beginning of the session loop.
			}
			else {
				if (integrationChoice == 2) {

					TrapezoidalFormula(*trapFormObj) = new TrapezoidalFormula; // Creates pointer to TrapezoidalFormula object. Must be destroyed at the end of the switch structure to make sure memory is managed properly.
					cout << (*trapFormObj) << endl; // Prints the result of the trapezoidal integration.

					cout << "Would you like to see the table of values of the intermediate x and y values?\n"\
						<< "Enter 0 for no or 1 for yes: ";
					printTableChoice = inputValditionForChoice(0, 2);
					cout << "\n";
					if (printTableChoice == 1) {
						(*trapFormObj).printTable(); // Prints the table of values.
					}

					delete trapFormObj; // Deletes the object so that the memory space can be reallocated for the next objects and so that the reinitialization of the members of the base class: NumericIntegration, will be new each time a new object is created in the next iteration of the loop.

					continue; // Skips back to the beginning of the session loop.
				}
				else {
					if (integrationChoice == 3) {
						ParabolicFormula(*parabFormObj) = new ParabolicFormula; // Creates pointer to ParabolicFormula object. Must be destroyed at the end of the switch structure to make sure memory is managed properly.
						cout <<(*parabFormObj) << endl; // Prints the result of the parabolic integration.

						cout << "Would you like to see the table of values of the intermediate x and y values?\n"\
							<< "Enter 0 for no or 1 for yes: ";
						printTableChoice = inputValditionForChoice(0, 2);
						cout << "\n";
						if (printTableChoice == 1) {
							(*parabFormObj).printTable(); // Prints the table of values.
						}

						delete parabFormObj; // Deletes the object so that the memory space can be reallocated for the next objects and so that the reinitialization of the members of the base class: NumericIntegration, will be new each time a new object is created in the next iteration of the loop.

						continue; // Skips back to the beginning of the session loop.
					}
					else {
						// If the choice is greater than 3 or less than 0 then it ends the program with the appropriate error message.
						if (integrationChoice < 0 || integrationChoice > 3) {
							cout << "Choice was out of range of valid choices.\n";
							exit(1); // Exits the program
						}
					}
					
				}
			}
		}
	
		isSessionDone = true; // Ends the session when set to true.
	}
	return 0;
}

// Validates the choice input which is used to control which object is created in the main program.
// Also used to determine if the tables are printed based on if the user inputs 0 (No) or 1 (Yes).
int inputValditionForChoice(int min, int max) {

	bool isNotDone = true;
	int choice;

	// Input validation loop for the choice that runs 
	do {

		try {

			cin >> choice;

			// This checks to see if the input is a valid type(int), if not it throws an exception and fixes the input stream.
			if (!cin.good()) {
				throw invalid_argument("Invalid choice: Only enter numbers, not letters or any other characters. \nEnter choice: ");
			}
			// If the choice was in the accepted range(0 to 3) then the input validation loop will end otherwise it will throw an out of range exception.
			if (min < choice < max) {
				isNotDone = false;
			}
			else {
				throw out_of_range("Input is not in the valid range.\nEnter choice: ");
			}
		}
		catch (invalid_argument errMsg) {

			cout << errMsg.what();
			cin.clear(); // Clears the input stream's error flags.
			cin.ignore(INT_MAX, '\n'); // Clears the input buffer up to the newline character.
		}
		catch (out_of_range errMsg) {

			cout << errMsg.what();
			cin.clear(); // Clears the input stream's error flags.
		}

	} while (isNotDone);

	return choice;
}


/*
Useful lines of code:
std::cout << "Min = " << std::numeric_limits<double>::min() << "\n";
std::cout << "Max = " << std::numeric_limits<double>::max() << "\n";

Unused lines of code:

*/